## 智能指针(线程安全方面)

### 析构函数&&多线程

竟态条件(race condition) 当一个线程要销毁对象时却出现另一个线程使用对象出现了崩盘的现象

MutexLock 与 MutexLockGuard

MutexLock 封装临界区(critical section) 封装互斥器的创建与销毁

MutexLockGuard 封装临界区的进入和退出，加锁和解锁

都不允许拷贝和赋值

对象构造做到线程安全： 在构造期间不要泄漏this指针：

1. 不要在构造函数注册任何回调

2. 也不要在构造函数中把this传给跨线程的对象

3. 即便在构造函数的最后一行也不行



一般采用二段式构造：constructor+initialize() (根据返回值判断对象是否构造成功)



销毁太难

成员函数用来保护临界区的互斥器本身必须是有效的，而析构函数破坏了这一假设，**它会把mutex成员变量销毁掉，这就造成了成员函数很有可能永远阻塞在那里**

MutexLock成员的生命期最多与对象一样长

**析构过程本来就不需要保护，因为只有别的线程都访问不到这个对象时，析构才是安全的**

如果要同时读写一个class的两个对象，有潜在死锁的可能 swap

一个函数如果锁住多个类型相同的对象，为了保证始终按照相同的顺序加锁，我们可以比较mutex对象的地址，**始终先加锁地址较小的mutex**



### 原始指针的弊端&&智能指针的优势

如果对象x注册了任何非静态成员函数的回调，那么必然在某处持有了指向x的指针，于是在多线程的情况下：

正在析构的对象(原始指针已经不起作用)正在调用非静态成员函数(线程不安全)

所以我们应该保存的是别的什么东西，能够分辨对象是否存活

引入一层间接性，让多个指针指向它，但这也可能出现问题，就是我们不知何时销毁间接层，所以引入引用计数，当引用计数为0的时候，这时候就可以安全地销毁间接和对象，这就是引用计数型指针(用对象来管理共享资源，共享资源指的是原本的对象 Object)



### shared_ptr && weak_ptr

shared_ptr作为引用型智能指针，控制对象的生命周期，强引用，只要有一个指向x对象的shared_ptr存在，该x对象就不会析构，当指向x的最后一个shared_ptr析构或reset()的时候，x保证会被销毁

weak_ptr不控制对象的生命周期，但是他知道对象还活着，如果对象还活着，那么它就可以提升为有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr.提升/lock的行为是线程安全的

shared_ptr 和weak_ptr的计数在主流平台上是原子操作，没有用锁，性能不俗

一旦某地想不再被引用，系统刻不容缓，立即回收内存，这通常发生在关键人物完成后的清理时期，不会影响关键任务的实时性，同时，内存里的对象都是有用的，绝对没有垃圾空占内存



### shared_ptr线程安全(shared_ptr对象本身)

一个shared_ptr对象实体可被多个线程同时读取

两个shared_ptr实体可以被两个线程同时写入，析构算写操作

**如果要从多个线程读写同一个shared_ptr对象，那么需要加锁**



### shared_ptr技术与陷阱

**意外延长对象的生命周期**

shared_ptr允许拷贝构造和赋值，如果不小心遗留了一个拷贝，那么对象就永世长存



**函数参数**

shared_ptr的拷贝开销比拷贝原始指针要高，多数情况下它可以以**const_reference**方式传递，一个线程只需要在最外层函数有一个实体对象，之后都可以用const_reference来使用这个shared_ptr

引用传递参数时不存在拷贝动作



**析构动作在创建时被捕获**

析构行为可以是函数指针，仿函数



**RALL**